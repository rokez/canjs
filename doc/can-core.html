<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE -- ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: [object Object]
	@page can-core
######################################################################## -->
<html lang="en">
<head>
	<meta charset="utf-8">
	<title></title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	
	<link rel="stylesheet" type="text/css" href="./static/bundles/bit-docs-site/static.css">
	
</head>

<body>
  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger">Menu</label>
  <header><nav class="navbar">
	<a class="brand" href="../index.html">CanJS</a>

	<ul class="bitovi-menu">
		<li class="dropdown">
			<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
			<ul class="dropdown-menu">
				<li><a href="http://bitovi.com">Bitovi.com</a></li>
				<li><a href="http://bitovi.com/blog/">Blog</a></li>
				<li><a href="http://bitovi.com/consulting/">Consulting</a></li>
				<li><a href="http://bitovi.com/training/">Training</a></li>
				<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
			</ul>
		</li>
	</ul>

	<ul class="navbar-items">
		<li class="dropdown">
				<a href="http://github.com/canjs/canjs">Github</a>
				<ul class="dropdown-menu">
      		<li><a href="http://github.com/canjs/can-connect">can-connect</a></li>
					<li><a href=".">can-set</a></li>
					<li><a href=".">can-compute</a></li>
					<li><a href=".">can-component</a></li>
				</ul>
		</li>
		<li>
			<a href="https://gitter.im/canjs/canjs">Chat</a>
		</li>
		<li>
			<a href="http://forums.donejs.com/c/canjs">Forum</a>
		</li>
	</ul>

</nav>
</header>
  	<div class="main-container">
  
  	<nav class="sidebar">
    
        
	<ul>
		
			
				
					<li class="current
                               parent
                               expanded">
						<a class="page"
							href="can-core.html">
							Core
						</a>
						
							
	<ul>
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-component.html">
							can-component
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-compute.html">
							can-compute
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-connect.html">
							can-connect
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-construct.html">
							can-construct
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-define.html">
							can-define
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-define/list/list.html">
							can-define/list/list
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-define/map/map.html">
							can-define/map/map
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="function"
							href="can-route.html">
							can-route
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-route-pushstate.html">
							can-route-pushstate
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-set.html">
							can-set
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-stache.html">
							can-stache
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-stache-bindings.html">
							can-stache-bindings
						</a>
						
					</li>
				

			
		
	</ul>


						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="can-ecosystem.html">
							Ecosystem
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="can-infrastructure.html">
							Infrastructure
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="can-legacy.html">
							Legacy
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="guides.html">
							Guides
						</a>
						
					</li>
				

			
		
	</ul>


    
</nav>
  

  <div class="content-container">
    <article>
    	
    		<section class="title">
	<h1>Core</h1>
</section>

    	

        

    	
    		
    			<section class="description">
    <p>The best, most hardened and generally useful libraries in CanJS.</p>

</section>

    		
    	

    
    
    
    
    


    	
    		
    			<section class="body">
    <h2>Use</h2>
<p>CanJS's core libraries are the modules most commonly used to build web
applications.  Each module is part of an independent package, so you
should install the ones you use directly:</p>
<pre><code>npm install can-define can-set can-connect can-component can-stache can-route --save
</code></pre>
<p>Lets export each one a bit more.</p>
<h2>can-compute</h2>
<p><a href="can-compute.html">can-compute</a>s represent an observable value.  A compute can contain its
own value and notify listeners of changes like:</p>
<pre><code class="language-js">var compute = require(&quot;can-compute&quot;);

var name = compute(&quot;Justin&quot;);

// read the value
name() //-&gt; &quot;Justin&quot;

name.on(&quot;change&quot;, function(ev, newVal, oldVal){
    newVal //-&gt; &quot;Matthew&quot;
    oldVal //-&gt; &quot;Justin&quot;
});

name(&quot;Matthew&quot;);
</code></pre>
<p>More commonly, a compute derives its value from other observables:</p>
<pre><code class="language-js">var DefineMap = require(&quot;can-define/map/map&quot;),
    DefineList = require(&quot;can-define/list/list&quot;),
    compute = require(&quot;can-compute&quot;);

var person = new DefineMap({first: &quot;Justin&quot;, last: &quot;Meyer&quot;}),
    hobbies = new DefineList([&quot;js&quot;,&quot;bball&quot;]),
    age = compute(33);

var info = compute(function(){
    return person.first +&quot; &quot;+ person.last+ &quot; is &quot;+age()+
        &quot;and like &quot;+hobbies.join(&quot;, &quot;)+&quot;.&quot;;
});

info() //-&gt; &quot;Justin Meyer is 33 and likes js, bball.&quot;

info.on(&quot;change&quot;, function(ev, newVal){
    newVal //-&gt; &quot;Justin Meyer is 33 and likes js.&quot;
});

hobbies.pop();
</code></pre>
<h2>can-define</h2>
<p><a href="can-define/map/map.html">can-define/map/map</a> and <a href="can-define/list/list.html">can-define/list/list</a> allow you to create observable
maps and lists with well defined properties.  You can
<a href="can-define.types.propDefinition.html">define a property's type initial value, enumerability, getter-setters and much more</a>.
For example, you can define the behavior of a <code>Todo</code> type and a <code>TodoList</code> type as follows:</p>
<pre><code class="language-js">var DefineMap = require(&quot;can-define/map/map&quot;);
var DefineList = require(&quot;can-define/list/list&quot;);

var Todo = DefineMap.extend({
  name: &quot;string&quot;,
  complete: {type: &quot;boolean&quot;, value: false},
  dueDate: &quot;date&quot;,
  isPastDue: {
    get: function(){
      return new Date() &lt;  this.dueDate;
    }
  },
  toggleComplete: function(){
    this.complete = !this.complete;
  }
});

var TodoList = DefineList.extend({
  &quot;*&quot;: Todo,
  completeCount: {
    get: function(){
      return this.filter(&quot;complete&quot;).length;
    }
  }
});
</code></pre>
<p>This allows you to create a Todo, read its properties, and
call back its methods like:</p>
<pre><code class="language-js">var dishes = new Todo({
    name: &quot;do dishes&quot;,
    // due yesterday
    dueDate: new Date() - 1000 * 60 * 60 * 24
});
dishes.name      //-&gt; &quot;do dishes&quot;
dishes.isPastDue //-&gt; true
dishes.complete  //-&gt; false
dishes.toggleComplete()  
dishes.complete  //-&gt; true
</code></pre>
<p>And it allows you to create a <code>TodoList</code>, access its items and properties
like:</p>
<pre><code class="language-js">var todos = new TodoList( dishes, {name: &quot;mow lawn&quot;, dueDate: new Date()});
todos.length         //-&gt; 2
todos[0].complete    //-&gt; true
todos.completeCount //-&gt; 1
</code></pre>
<p>These observables provide the foundation
for data connection (models), view-models and even routing in your application.</p>
<h2>can-set</h2>
<p><a href="can-set.html">can-set</a> models a service layer's behavior as a <a href="can-set.Algebra.html">set.Algebra</a>. Once modeled, other libraries such as <a href="can-connect.html">can-connect</a> or [can-fixture] can
add a host of functionality like: real-time behavior, performance optimizations, and
simulated service layers.</p>
<p>A <code>todosAlgebra</code> set algebra for a <code>GET /api/todos</code> service might look like:</p>
<pre><code class="language-js">var set = require(&quot;can-set&quot;);
var todosAlgebra = new set.Algebra(
    // specify the unique identifier property on data
    set.prop.id(&quot;_id&quot;),  
    // specify that completed can be true, false or undefined
    set.prop.boolean(&quot;complete&quot;),
    // specify the property that controls sorting
    set.prop.sort(&quot;orderBy&quot;)
)
</code></pre>
<p>This assumes that the service:</p>
<ul>
<li>Returns data where the unique property name is <code>_id</code>:
<pre><code class="language-js">GET /api/todos
-&gt; [{_id: 1, name: &quot;mow lawn&quot;, complete: true},
    {_id: 2, name: &quot;do dishes&quot;, complete: false}, ...]
</code></pre></li>
<li>Can filter by a <code>complete</code> property:
<pre><code class="language-js">GET /api/todos?complete=false
-&gt; [{_id: 2, name: &quot;do dishes&quot;, complete: false}, ...]
</code></pre></li>
<li>Sorts by an <code>orderBy</code> property:
<pre><code class="language-js">GET /api/todos?orderBy=name
-&gt; [{_id: 2, name: &quot;do dishes&quot;, complete: false},
    {_id: 1, name: &quot;mow lawn&quot;, complete: true}]
</code></pre></li>
</ul>
<h2>can-connect</h2>
<p><a href="can-connect.html">can-connect</a> connects a data type, typically a <code>DefineMap</code> and its <code>DefineList</code>,
to a service layer. This is often done via the
[can-connect/can/super-map] module which bundles many common behaviors
and performance techniques into a single api:</p>
<pre><code class="language-js">var superMap = require(&quot;can-connect/can/super-map/super-map&quot;),
    DefineMap = require(&quot;can-define/map/map&quot;),
    DefineList = require(&quot;can-define/list/list&quot;),
    set = require(&quot;can-set&quot;);

var Todo = DefineMap.extend({
    ...
});
var TodosList = DefineMap.extend({
    &quot;*&quot;: Todo,
    ...
});
var todosAlgebra = new set.Algebra({
    ...
});

var connection = superMap({
    url: &quot;/api/todos&quot;,
    Map: Todo,
    List: TodoList,
    algebra: todosAlgebra,
    name: &quot;todo&quot;
});
</code></pre>
<p><code>superMap</code> extends the <code>Map</code> type, in this case, <code>Todo</code>, with
the ability to make requests to the service layer.</p>
<ul>
<li>Get a list of Todos
<pre><code class="language-js">Todo.getList({complete: true}).then(function(todos){})
</code></pre></li>
<li>Get a single Todo
<pre><code class="language-js">Todo.get({_id: 6}).then(function(todo){})
</code></pre></li>
<li>Create a Todo
<pre><code class="language-js">var todo = new Todo({name: &quot;do dishes&quot;, complete: false})
todo.save().then(function(todo){})
</code></pre></li>
<li>Update an already created Todo
<pre><code class="language-js">todo.complete = true;
todo.save().then(function(todo){})
</code></pre></li>
<li>Delete a Todo
<pre><code class="language-js">todo.destroy().then(function(todo){})
</code></pre></li>
</ul>
<p><a href="can-connect.html">can-connect</a> is also middleware, so custom connections can
be assembled too:</p>
<pre><code class="language-js">var base = require(&quot;can-connect/base/base&quot;);
var dataUrl = require(&quot;can-connect/data-url/data-url&quot;);
var constructor = require(&quot;can-connect/constructor/constructor&quot;);
var map = require(&quot;can-connect/can/map/map&quot;);

var options = {
    url: &quot;/api/todos&quot;,
    Map: Todo,
    List: TodoList,
    algebra: todosAlgebra,
    name: &quot;todo&quot;
}
var connection = map(constructor(dataUrl(base(options))));
</code></pre>
<h2>can-stache</h2>
<p><a href="can-stache.html">can-stache</a> provides live binding mustache and handlebars syntax. While
templates should typically be loaded with a module loader like <a href="steal-stache.html">steal-stache</a>,
you can create a template programmatically that lists out todos within a
promise loaded from <code>Todo.getList</code> like:</p>
<pre><code class="language-js">var stache = require(&quot;can-stache&quot;);

// Creates a template
var template = stache(
    &quot;&lt;ul&gt;&quot;+
        &quot;{{#if todos.isPending}}&lt;li&gt;Loading...&lt;/li&gt;{{/if}}&quot;+
        &quot;{{#if todos.isResolved}}&quot;+
            &quot;{{#each todos.value}}&quot;+
                &quot;&lt;li class='{{#complete}}complete{{/complete}}'&gt;{{name}}&lt;/li&gt;&quot;+
            &quot;{{else}}&quot;+
                &quot;&lt;li&gt;No todos&lt;/li&gt;&quot;+
            &quot;{{/each}}&quot;+
        &quot;{{/if}}&quot;+
    &quot;&lt;/ul&gt;&quot;);

// Calls the template with some data
var frag = template({
    todos: Todo.getList({})
});

// Inserts the result into the page
document.body.appendChild(frag);
</code></pre>
<p><a href="can-stache.html">can-stache</a> templates use magic tags like <code>{{}}</code> to control what
content is rendered. The most common forms of those magic tags are:</p>
<ul>
<li><a href="can-stache.tags.escaped.html">{{key}}</a> - Insert the value at <code>key</code> in the page. If <code>key</code> is a function or helper, run it and insert the result.</li>
<li><a href="can-stache.tags.section.html">{{#key}}...{{/key}}</a> - Render the content between magic tags based on some criteria.</li>
</ul>
<p><a href="can-stache.html">can-stache</a> templates return document fragments that update whenever
their source data changes.</p>
<h2>can-component</h2>
<p><a href="can-component.html">can-component</a> creates custom elements with unit-testable view models. It
combines a view model created by <a href="can-define/map/map.html">can-define/map/map</a> with a template
created by <a href="can-stache.html">can-stache</a>.</p>
<pre><code class="language-js">var Component = require(&quot;can-component&quot;);
var DefineMap = require(&quot;can-define/map/map&quot;);
var stache = require(&quot;can-stache&quot;);

// Defines the todos-list view model
var TodosListVM = DefineMap.extend({
    // An initial value that is a promise containing the
    // list of all todos.
    todos: {
        value: function(){
            return Todo.getList({});
        }
    },
    // A method that toggles a todo's complete property
    // and updates the todo on the server.
    toggleComplete: function(todo){
        todo.complete = !todo.complete;
        todo.save();
    }
});

Component.extend({
    tag: &quot;todos-list&quot;,
    ViewModel: TodosVM,
    view: stache(
        &quot;&lt;ul&gt;&quot;+
            &quot;{{#if todos.isPending}}&lt;li&gt;Loading...&lt;/li&gt;{{/if}}&quot;+
            &quot;{{#if todos.isResolved}}&quot;+
                &quot;{{#each todos.value}}&quot;+
                    &quot;&lt;li ($click)='toggleComplete(.)'&quot;+
                         &quot;class='{{#complete}}complete{{/complete}}'&gt;{{name}}&lt;/li&gt;&quot;+
                &quot;{{else}}&quot;+
                    &quot;&lt;li&gt;No todos&lt;/li&gt;&quot;+
                &quot;{{/each}}&quot;+
            &quot;{{/if}}&quot;+
        &quot;&lt;/ul&gt;&quot;);
});
</code></pre>
<h2>can-stache-bindings</h2>
<p><a href="can-stache-bindings.html">can-stache-bindings</a> provides <a href="can-view-callbacks.attr.html">custom attributes</a> for
<a href="can-stache.html">can-stache</a> event and data bindings.</p>
<p>Bindings look like:</p>
<ul>
<li><code>(event)=&quot;key()&quot;</code> for event binding.</li>
<li><code>{prop}=&quot;key&quot;</code> for one-way binding to a child.</li>
<li><code>{^prop}=&quot;key&quot;</code> for one-way binding to a parent.</li>
<li><code>{(prop)}=&quot;key&quot;</code> for two-way binding.</li>
</ul>
<p>Adding <code>$</code> to a binding like <code>($event)=&quot;key()&quot;</code> changes the binding from the viewModel to the element's attributes or properties.</p>
<p><a href="can-stache-bindings.event.html">Event</a> binding examples:</p>
<pre><code class="language-html">&lt;!-- calls `toggleComplete` when the li is clicked --&gt;
&lt;li ($click)=&quot;toggleComplete(.)&quot;/&gt;

&lt;!-- calls `resetData` when cancel is dispatched on `my-modal`'s view model --&gt;
&lt;my-modal (cancel)=&quot;resetData()&quot;/&gt;
</code></pre>
<p><a href="can-stache-bindings.toChild.html">One-way to child</a> examples:</p>
<pre><code class="language-html">&lt;!-- updates input's `checked` property with the value of complete --&gt;
&lt;input type=&quot;checkbox&quot; {$checked}=&quot;complete&quot;/&gt;

&lt;!-- updates `todo-lists`'s  `todos` property with the result of `getTodos`--&gt;
&lt;todos-list {todos}=&quot;getTodos(complete=true)&quot;/&gt;
</code></pre>
<p><a href="can-stache-bindings.toChild.html">One-way to parent</a> examples:</p>
<pre><code class="language-html">&lt;!-- updates `complete` with input's `checked` property --&gt;
&lt;input type=&quot;checkbox&quot; {^$checked}=&quot;complete&quot;/&gt;

&lt;!-- updates `todosList` with `todo-lists`'s `todos` property --&gt;
&lt;todos-list {^todos}=&quot;todosList&quot;/&gt;
</code></pre>
<p><a href="can-stache-bindings.twoWay.html">Two-way</a> examples:</p>
<pre><code class="language-html">&lt;!-- Updates the input's `value` with `name` and vice versa --&gt;
&lt;input type=&quot;text&quot; {($value)}=&quot;name&quot;/&gt;

&lt;!-- Updates `date-picker`'s `date` with `dueDate` and vice versa --&gt;
&lt;date-picker {(date)}=&quot;dueDate&quot;/&gt;
</code></pre>
<h2>can-route and can-route-pushstate</h2>
<p><a href="can-route.html">can-route</a> connects a <code>DefineMap</code>'s properties to values in the
url. Create a map type, connect it to the url, and begin routing like:</p>
<pre><code class="language-js">var route = require(&quot;can-route&quot;);
var DefineMap = require(&quot;can-define/map/map&quot;);

var AppViewModel = DefineMap.extend({
    seal: false
},{
    // Sets the default type to string
    &quot;*&quot;: &quot;string&quot;,
    todoId: &quot;string&quot;,
    todo: {
        get: function(){
            if(this.todoId) {
                return Todo.get({_id: this.todoId})
            }
        }
    }
});

var appViewModel = new AppViewModel();
route.map(appViewModel);

route.ready();
</code></pre>
<p>When the url changes, to something like <code>#!&amp;todoId=5</code>, so will the
<code>appViewModel</code>'s <code>todoId</code> and <code>todo</code> property:</p>
<pre><code class="language-js">appViewModel.todoId //-&gt; &quot;5&quot;
appViewModel.todo   //-&gt; Promise&lt;Todo&gt;
</code></pre>
<p>Similarly, if <code>appViewModel</code>'s <code>todoId</code> is set like:</p>
<pre><code class="language-js">appViewModel.todoId = 6;
</code></pre>
<p>The hash will be updated:</p>
<pre><code class="language-js">window.location.hash //-&gt; &quot;#!&amp;todoId=6&quot;
</code></pre>
<p>The <code>route</code> function can be used to specify pretty routing rules that
translate property changes to a url and a url to property changes. For example,</p>
<pre><code class="language-js">// a route like:
route(&quot;todo/:todoId&quot;);

// and a hash like:
window.location.hash = &quot;#!todo/7&quot;;

// produces an appViewModel like:
appViewModel.serialize() //-&gt; {route: &quot;todo/:todoId&quot;, todoId: &quot;7&quot;}
</code></pre>
<p><a href="can-route-pushstate.html">can-route-pushstate</a> adds <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">pushstate</a> support. It
mixes in this behavior so you just need to import the module:</p>
<pre><code class="language-js">var route = require(&quot;can-route&quot;);
require(&quot;can-route-pushstate&quot;);
</code></pre>

</section>

    		
    	

    </article>
  </div>
</div>

  <footer><p>CanJS is part of <a href="http://donejs.com">DoneJS</a>. Created and maintained by the open source team at <a href="http://bitovi.com">Bitovi</a>. <strong>Currently v3.0.0.</strong></p></footer>
	<script type="text/javascript">
		var docObject = {"content":"<div class=\"main-container\">\n  \n  \t<nav class=\"sidebar\">\n    \n        \n\t<ul>\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"current\n                               parent\n                               expanded\">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-core.html\">\n\t\t\t\t\t\t\tCore\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t<ul>\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-component.html\">\n\t\t\t\t\t\t\tcan-component\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-compute.html\">\n\t\t\t\t\t\t\tcan-compute\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-connect.html\">\n\t\t\t\t\t\t\tcan-connect\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-construct.html\">\n\t\t\t\t\t\t\tcan-construct\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-define.html\">\n\t\t\t\t\t\t\tcan-define\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-define/list/list.html\">\n\t\t\t\t\t\t\tcan-define/list/list\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-define/map/map.html\">\n\t\t\t\t\t\t\tcan-define/map/map\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"function\"\n\t\t\t\t\t\t\thref=\"can-route.html\">\n\t\t\t\t\t\t\tcan-route\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-route-pushstate.html\">\n\t\t\t\t\t\t\tcan-route-pushstate\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-set.html\">\n\t\t\t\t\t\t\tcan-set\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-stache.html\">\n\t\t\t\t\t\t\tcan-stache\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-stache-bindings.html\">\n\t\t\t\t\t\t\tcan-stache-bindings\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t</ul>\n\n\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-ecosystem.html\">\n\t\t\t\t\t\t\tEcosystem\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-infrastructure.html\">\n\t\t\t\t\t\t\tInfrastructure\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-legacy.html\">\n\t\t\t\t\t\t\tLegacy\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"guides.html\">\n\t\t\t\t\t\t\tGuides\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t</ul>\n\n\n    \n</nav>\n  \n\n  <div class=\"content-container\">\n    <article>\n    \t\n    \t\t<section class=\"title\">\n\t<h1>Core</h1>\n</section>\n\n    \t\n\n        \n\n    \t\n    \t\t\n    \t\t\t<section class=\"description\">\n    <p>The best, most hardened and generally useful libraries in CanJS.</p>\n\n</section>\n\n    \t\t\n    \t\n\n    \n    \n    \n    \n    \n\n\n    \t\n    \t\t\n    \t\t\t<section class=\"body\">\n    <h2>Use</h2>\n<p>CanJS's core libraries are the modules most commonly used to build web\napplications.  Each module is part of an independent package, so you\nshould install the ones you use directly:</p>\n<pre><code>npm install can-define can-set can-connect can-component can-stache can-route --save\n</code></pre>\n<p>Lets export each one a bit more.</p>\n<h2>can-compute</h2>\n<p><a href=\"can-compute.html\">can-compute</a>s represent an observable value.  A compute can contain its\nown value and notify listeners of changes like:</p>\n<pre><code class=\"language-js\">var compute = require(&quot;can-compute&quot;);\n\nvar name = compute(&quot;Justin&quot;);\n\n// read the value\nname() //-&gt; &quot;Justin&quot;\n\nname.on(&quot;change&quot;, function(ev, newVal, oldVal){\n    newVal //-&gt; &quot;Matthew&quot;\n    oldVal //-&gt; &quot;Justin&quot;\n});\n\nname(&quot;Matthew&quot;);\n</code></pre>\n<p>More commonly, a compute derives its value from other observables:</p>\n<pre><code class=\"language-js\">var DefineMap = require(&quot;can-define/map/map&quot;),\n    DefineList = require(&quot;can-define/list/list&quot;),\n    compute = require(&quot;can-compute&quot;);\n\nvar person = new DefineMap({first: &quot;Justin&quot;, last: &quot;Meyer&quot;}),\n    hobbies = new DefineList([&quot;js&quot;,&quot;bball&quot;]),\n    age = compute(33);\n\nvar info = compute(function(){\n    return person.first +&quot; &quot;+ person.last+ &quot; is &quot;+age()+\n        &quot;and like &quot;+hobbies.join(&quot;, &quot;)+&quot;.&quot;;\n});\n\ninfo() //-&gt; &quot;Justin Meyer is 33 and likes js, bball.&quot;\n\ninfo.on(&quot;change&quot;, function(ev, newVal){\n    newVal //-&gt; &quot;Justin Meyer is 33 and likes js.&quot;\n});\n\nhobbies.pop();\n</code></pre>\n<h2>can-define</h2>\n<p><a href=\"can-define/map/map.html\">can-define/map/map</a> and <a href=\"can-define/list/list.html\">can-define/list/list</a> allow you to create observable\nmaps and lists with well defined properties.  You can\n<a href=\"can-define.types.propDefinition.html\">define a property's type initial value, enumerability, getter-setters and much more</a>.\nFor example, you can define the behavior of a <code>Todo</code> type and a <code>TodoList</code> type as follows:</p>\n<pre><code class=\"language-js\">var DefineMap = require(&quot;can-define/map/map&quot;);\nvar DefineList = require(&quot;can-define/list/list&quot;);\n\nvar Todo = DefineMap.extend({\n  name: &quot;string&quot;,\n  complete: {type: &quot;boolean&quot;, value: false},\n  dueDate: &quot;date&quot;,\n  isPastDue: {\n    get: function(){\n      return new Date() &lt;  this.dueDate;\n    }\n  },\n  toggleComplete: function(){\n    this.complete = !this.complete;\n  }\n});\n\nvar TodoList = DefineList.extend({\n  &quot;*&quot;: Todo,\n  completeCount: {\n    get: function(){\n      return this.filter(&quot;complete&quot;).length;\n    }\n  }\n});\n</code></pre>\n<p>This allows you to create a Todo, read its properties, and\ncall back its methods like:</p>\n<pre><code class=\"language-js\">var dishes = new Todo({\n    name: &quot;do dishes&quot;,\n    // due yesterday\n    dueDate: new Date() - 1000 * 60 * 60 * 24\n});\ndishes.name      //-&gt; &quot;do dishes&quot;\ndishes.isPastDue //-&gt; true\ndishes.complete  //-&gt; false\ndishes.toggleComplete()  \ndishes.complete  //-&gt; true\n</code></pre>\n<p>And it allows you to create a <code>TodoList</code>, access its items and properties\nlike:</p>\n<pre><code class=\"language-js\">var todos = new TodoList( dishes, {name: &quot;mow lawn&quot;, dueDate: new Date()});\ntodos.length         //-&gt; 2\ntodos[0].complete    //-&gt; true\ntodos.completeCount //-&gt; 1\n</code></pre>\n<p>These observables provide the foundation\nfor data connection (models), view-models and even routing in your application.</p>\n<h2>can-set</h2>\n<p><a href=\"can-set.html\">can-set</a> models a service layer's behavior as a <a href=\"can-set.Algebra.html\">set.Algebra</a>. Once modeled, other libraries such as <a href=\"can-connect.html\">can-connect</a> or [can-fixture] can\nadd a host of functionality like: real-time behavior, performance optimizations, and\nsimulated service layers.</p>\n<p>A <code>todosAlgebra</code> set algebra for a <code>GET /api/todos</code> service might look like:</p>\n<pre><code class=\"language-js\">var set = require(&quot;can-set&quot;);\nvar todosAlgebra = new set.Algebra(\n    // specify the unique identifier property on data\n    set.prop.id(&quot;_id&quot;),  \n    // specify that completed can be true, false or undefined\n    set.prop.boolean(&quot;complete&quot;),\n    // specify the property that controls sorting\n    set.prop.sort(&quot;orderBy&quot;)\n)\n</code></pre>\n<p>This assumes that the service:</p>\n<ul>\n<li>Returns data where the unique property name is <code>_id</code>:\n<pre><code class=\"language-js\">GET /api/todos\n-&gt; [{_id: 1, name: &quot;mow lawn&quot;, complete: true},\n    {_id: 2, name: &quot;do dishes&quot;, complete: false}, ...]\n</code></pre></li>\n<li>Can filter by a <code>complete</code> property:\n<pre><code class=\"language-js\">GET /api/todos?complete=false\n-&gt; [{_id: 2, name: &quot;do dishes&quot;, complete: false}, ...]\n</code></pre></li>\n<li>Sorts by an <code>orderBy</code> property:\n<pre><code class=\"language-js\">GET /api/todos?orderBy=name\n-&gt; [{_id: 2, name: &quot;do dishes&quot;, complete: false},\n    {_id: 1, name: &quot;mow lawn&quot;, complete: true}]\n</code></pre></li>\n</ul>\n<h2>can-connect</h2>\n<p><a href=\"can-connect.html\">can-connect</a> connects a data type, typically a <code>DefineMap</code> and its <code>DefineList</code>,\nto a service layer. This is often done via the\n[can-connect/can/super-map] module which bundles many common behaviors\nand performance techniques into a single api:</p>\n<pre><code class=\"language-js\">var superMap = require(&quot;can-connect/can/super-map/super-map&quot;),\n    DefineMap = require(&quot;can-define/map/map&quot;),\n    DefineList = require(&quot;can-define/list/list&quot;),\n    set = require(&quot;can-set&quot;);\n\nvar Todo = DefineMap.extend({\n    ...\n});\nvar TodosList = DefineMap.extend({\n    &quot;*&quot;: Todo,\n    ...\n});\nvar todosAlgebra = new set.Algebra({\n    ...\n});\n\nvar connection = superMap({\n    url: &quot;/api/todos&quot;,\n    Map: Todo,\n    List: TodoList,\n    algebra: todosAlgebra,\n    name: &quot;todo&quot;\n});\n</code></pre>\n<p><code>superMap</code> extends the <code>Map</code> type, in this case, <code>Todo</code>, with\nthe ability to make requests to the service layer.</p>\n<ul>\n<li>Get a list of Todos\n<pre><code class=\"language-js\">Todo.getList({complete: true}).then(function(todos){})\n</code></pre></li>\n<li>Get a single Todo\n<pre><code class=\"language-js\">Todo.get({_id: 6}).then(function(todo){})\n</code></pre></li>\n<li>Create a Todo\n<pre><code class=\"language-js\">var todo = new Todo({name: &quot;do dishes&quot;, complete: false})\ntodo.save().then(function(todo){})\n</code></pre></li>\n<li>Update an already created Todo\n<pre><code class=\"language-js\">todo.complete = true;\ntodo.save().then(function(todo){})\n</code></pre></li>\n<li>Delete a Todo\n<pre><code class=\"language-js\">todo.destroy().then(function(todo){})\n</code></pre></li>\n</ul>\n<p><a href=\"can-connect.html\">can-connect</a> is also middleware, so custom connections can\nbe assembled too:</p>\n<pre><code class=\"language-js\">var base = require(&quot;can-connect/base/base&quot;);\nvar dataUrl = require(&quot;can-connect/data-url/data-url&quot;);\nvar constructor = require(&quot;can-connect/constructor/constructor&quot;);\nvar map = require(&quot;can-connect/can/map/map&quot;);\n\nvar options = {\n    url: &quot;/api/todos&quot;,\n    Map: Todo,\n    List: TodoList,\n    algebra: todosAlgebra,\n    name: &quot;todo&quot;\n}\nvar connection = map(constructor(dataUrl(base(options))));\n</code></pre>\n<h2>can-stache</h2>\n<p><a href=\"can-stache.html\">can-stache</a> provides live binding mustache and handlebars syntax. While\ntemplates should typically be loaded with a module loader like <a href=\"steal-stache.html\">steal-stache</a>,\nyou can create a template programmatically that lists out todos within a\npromise loaded from <code>Todo.getList</code> like:</p>\n<pre><code class=\"language-js\">var stache = require(&quot;can-stache&quot;);\n\n// Creates a template\nvar template = stache(\n    &quot;&lt;ul&gt;&quot;+\n        &quot;{{#if todos.isPending}}&lt;li&gt;Loading...&lt;/li&gt;{{/if}}&quot;+\n        &quot;{{#if todos.isResolved}}&quot;+\n            &quot;{{#each todos.value}}&quot;+\n                &quot;&lt;li class='{{#complete}}complete{{/complete}}'&gt;{{name}}&lt;/li&gt;&quot;+\n            &quot;{{else}}&quot;+\n                &quot;&lt;li&gt;No todos&lt;/li&gt;&quot;+\n            &quot;{{/each}}&quot;+\n        &quot;{{/if}}&quot;+\n    &quot;&lt;/ul&gt;&quot;);\n\n// Calls the template with some data\nvar frag = template({\n    todos: Todo.getList({})\n});\n\n// Inserts the result into the page\ndocument.body.appendChild(frag);\n</code></pre>\n<p><a href=\"can-stache.html\">can-stache</a> templates use magic tags like <code>{{}}</code> to control what\ncontent is rendered. The most common forms of those magic tags are:</p>\n<ul>\n<li><a href=\"can-stache.tags.escaped.html\">{{key}}</a> - Insert the value at <code>key</code> in the page. If <code>key</code> is a function or helper, run it and insert the result.</li>\n<li><a href=\"can-stache.tags.section.html\">{{#key}}...{{/key}}</a> - Render the content between magic tags based on some criteria.</li>\n</ul>\n<p><a href=\"can-stache.html\">can-stache</a> templates return document fragments that update whenever\ntheir source data changes.</p>\n<h2>can-component</h2>\n<p><a href=\"can-component.html\">can-component</a> creates custom elements with unit-testable view models. It\ncombines a view model created by <a href=\"can-define/map/map.html\">can-define/map/map</a> with a template\ncreated by <a href=\"can-stache.html\">can-stache</a>.</p>\n<pre><code class=\"language-js\">var Component = require(&quot;can-component&quot;);\nvar DefineMap = require(&quot;can-define/map/map&quot;);\nvar stache = require(&quot;can-stache&quot;);\n\n// Defines the todos-list view model\nvar TodosListVM = DefineMap.extend({\n    // An initial value that is a promise containing the\n    // list of all todos.\n    todos: {\n        value: function(){\n            return Todo.getList({});\n        }\n    },\n    // A method that toggles a todo's complete property\n    // and updates the todo on the server.\n    toggleComplete: function(todo){\n        todo.complete = !todo.complete;\n        todo.save();\n    }\n});\n\nComponent.extend({\n    tag: &quot;todos-list&quot;,\n    ViewModel: TodosVM,\n    view: stache(\n        &quot;&lt;ul&gt;&quot;+\n            &quot;{{#if todos.isPending}}&lt;li&gt;Loading...&lt;/li&gt;{{/if}}&quot;+\n            &quot;{{#if todos.isResolved}}&quot;+\n                &quot;{{#each todos.value}}&quot;+\n                    &quot;&lt;li ($click)='toggleComplete(.)'&quot;+\n                         &quot;class='{{#complete}}complete{{/complete}}'&gt;{{name}}&lt;/li&gt;&quot;+\n                &quot;{{else}}&quot;+\n                    &quot;&lt;li&gt;No todos&lt;/li&gt;&quot;+\n                &quot;{{/each}}&quot;+\n            &quot;{{/if}}&quot;+\n        &quot;&lt;/ul&gt;&quot;);\n});\n</code></pre>\n<h2>can-stache-bindings</h2>\n<p><a href=\"can-stache-bindings.html\">can-stache-bindings</a> provides <a href=\"can-view-callbacks.attr.html\">custom attributes</a> for\n<a href=\"can-stache.html\">can-stache</a> event and data bindings.</p>\n<p>Bindings look like:</p>\n<ul>\n<li><code>(event)=&quot;key()&quot;</code> for event binding.</li>\n<li><code>{prop}=&quot;key&quot;</code> for one-way binding to a child.</li>\n<li><code>{^prop}=&quot;key&quot;</code> for one-way binding to a parent.</li>\n<li><code>{(prop)}=&quot;key&quot;</code> for two-way binding.</li>\n</ul>\n<p>Adding <code>$</code> to a binding like <code>($event)=&quot;key()&quot;</code> changes the binding from the viewModel to the element's attributes or properties.</p>\n<p><a href=\"can-stache-bindings.event.html\">Event</a> binding examples:</p>\n<pre><code class=\"language-html\">&lt;!-- calls `toggleComplete` when the li is clicked --&gt;\n&lt;li ($click)=&quot;toggleComplete(.)&quot;/&gt;\n\n&lt;!-- calls `resetData` when cancel is dispatched on `my-modal`'s view model --&gt;\n&lt;my-modal (cancel)=&quot;resetData()&quot;/&gt;\n</code></pre>\n<p><a href=\"can-stache-bindings.toChild.html\">One-way to child</a> examples:</p>\n<pre><code class=\"language-html\">&lt;!-- updates input's `checked` property with the value of complete --&gt;\n&lt;input type=&quot;checkbox&quot; {$checked}=&quot;complete&quot;/&gt;\n\n&lt;!-- updates `todo-lists`'s  `todos` property with the result of `getTodos`--&gt;\n&lt;todos-list {todos}=&quot;getTodos(complete=true)&quot;/&gt;\n</code></pre>\n<p><a href=\"can-stache-bindings.toChild.html\">One-way to parent</a> examples:</p>\n<pre><code class=\"language-html\">&lt;!-- updates `complete` with input's `checked` property --&gt;\n&lt;input type=&quot;checkbox&quot; {^$checked}=&quot;complete&quot;/&gt;\n\n&lt;!-- updates `todosList` with `todo-lists`'s `todos` property --&gt;\n&lt;todos-list {^todos}=&quot;todosList&quot;/&gt;\n</code></pre>\n<p><a href=\"can-stache-bindings.twoWay.html\">Two-way</a> examples:</p>\n<pre><code class=\"language-html\">&lt;!-- Updates the input's `value` with `name` and vice versa --&gt;\n&lt;input type=&quot;text&quot; {($value)}=&quot;name&quot;/&gt;\n\n&lt;!-- Updates `date-picker`'s `date` with `dueDate` and vice versa --&gt;\n&lt;date-picker {(date)}=&quot;dueDate&quot;/&gt;\n</code></pre>\n<h2>can-route and can-route-pushstate</h2>\n<p><a href=\"can-route.html\">can-route</a> connects a <code>DefineMap</code>'s properties to values in the\nurl. Create a map type, connect it to the url, and begin routing like:</p>\n<pre><code class=\"language-js\">var route = require(&quot;can-route&quot;);\nvar DefineMap = require(&quot;can-define/map/map&quot;);\n\nvar AppViewModel = DefineMap.extend({\n    seal: false\n},{\n    // Sets the default type to string\n    &quot;*&quot;: &quot;string&quot;,\n    todoId: &quot;string&quot;,\n    todo: {\n        get: function(){\n            if(this.todoId) {\n                return Todo.get({_id: this.todoId})\n            }\n        }\n    }\n});\n\nvar appViewModel = new AppViewModel();\nroute.map(appViewModel);\n\nroute.ready();\n</code></pre>\n<p>When the url changes, to something like <code>#!&amp;todoId=5</code>, so will the\n<code>appViewModel</code>'s <code>todoId</code> and <code>todo</code> property:</p>\n<pre><code class=\"language-js\">appViewModel.todoId //-&gt; &quot;5&quot;\nappViewModel.todo   //-&gt; Promise&lt;Todo&gt;\n</code></pre>\n<p>Similarly, if <code>appViewModel</code>'s <code>todoId</code> is set like:</p>\n<pre><code class=\"language-js\">appViewModel.todoId = 6;\n</code></pre>\n<p>The hash will be updated:</p>\n<pre><code class=\"language-js\">window.location.hash //-&gt; &quot;#!&amp;todoId=6&quot;\n</code></pre>\n<p>The <code>route</code> function can be used to specify pretty routing rules that\ntranslate property changes to a url and a url to property changes. For example,</p>\n<pre><code class=\"language-js\">// a route like:\nroute(&quot;todo/:todoId&quot;);\n\n// and a hash like:\nwindow.location.hash = &quot;#!todo/7&quot;;\n\n// produces an appViewModel like:\nappViewModel.serialize() //-&gt; {route: &quot;todo/:todoId&quot;, todoId: &quot;7&quot;}\n</code></pre>\n<p><a href=\"can-route-pushstate.html\">can-route-pushstate</a> adds <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API\">pushstate</a> support. It\nmixes in this behavior so you just need to import the module:</p>\n<pre><code class=\"language-js\">var route = require(&quot;can-route&quot;);\nrequire(&quot;can-route-pushstate&quot;);\n</code></pre>\n\n</section>\n\n    \t\t\n    \t\n\n    </article>\n  </div>\n</div>\n","src":{"path":"docs/can-canjs/can-core.md"},"description":"The best, most hardened and generally useful libraries in CanJS.   \n","name":"can-core","title":"Core","type":"page","parent":"canjs","comment":" "};
	</script>

	
		<script>
		  steal = {
		    instantiated: {
		      "bundles/bit-docs-site/static.css!$css" : null
		    }
		  }
		</script>
		<script type='text/javascript'
				data-main="bit-docs-site/static"
				src="./static/node_modules/steal/steal.production.js"></script>
	
</body>

</html>
