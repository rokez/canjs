<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE -- ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: [object Object]
	@property can-component.prototype.viewModel
######################################################################## -->
<html lang="en">
<head>
	<meta charset="utf-8">
	<title></title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	
	<link rel="stylesheet" type="text/css" href="./static/bundles/bit-docs-site/static.css">
	
</head>

<body>
  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger">Menu</label>
  <header><nav class="navbar">
	<a class="brand" href="../index.html">CanJS</a>

	<ul class="bitovi-menu">
		<li class="dropdown">
			<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
			<ul class="dropdown-menu">
				<li><a href="http://bitovi.com">Bitovi.com</a></li>
				<li><a href="http://bitovi.com/blog/">Blog</a></li>
				<li><a href="http://bitovi.com/consulting/">Consulting</a></li>
				<li><a href="http://bitovi.com/training/">Training</a></li>
				<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
			</ul>
		</li>
	</ul>

	<ul class="navbar-items">
		<li class="dropdown">
				<a href="http://github.com/canjs/canjs">Github</a>
				<ul class="dropdown-menu">
      		<li><a href="http://github.com/canjs/can-connect">can-connect</a></li>
					<li><a href=".">can-set</a></li>
					<li><a href=".">can-compute</a></li>
					<li><a href=".">can-component</a></li>
				</ul>
		</li>
		<li>
			<a href="https://gitter.im/canjs/canjs">Chat</a>
		</li>
		<li>
			<a href="http://forums.donejs.com/c/canjs">Forum</a>
		</li>
	</ul>

</nav>
</header>
  	<div class="main-container">
  
  	<nav class="sidebar">
    
        
	<ul>
		
			
				
					<li class="
                               parent
                               expanded">
						<a class="page"
							href="can-core.html">
							Core
						</a>
						
							
	<ul>
		
			
				
					<li class="
                               parent
                               expanded">
						<a class="module"
							href="can-component.html">
							can-component
						</a>
						
							
	<ul>
		
			
				
					<li>
						<span>prototype</span>

						
	<ul>
		
			
				
					<li class="
                               
                               ">
						<a class="property"
							href="can-component.prototype.events.html">
							events
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="property"
							href="can-component.prototype.helpers.html">
							helpers
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="property"
							href="can-component.prototype.leakScope.html">
							leakScope
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="property"
							href="can-component.prototype.tag.html">
							tag
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="property"
							href="can-component.prototype.template.html">
							template
						</a>
						
					</li>
				

			
		
			
				
					<li class="current
                               parent
                               expanded">
						<a class="property"
							href="can-component.prototype.viewModel.html">
							viewModel
						</a>
						
							

						
					</li>
				

			
		
	</ul>


					</li>
				

			
		
			
				
					<li>
						<span>static</span>

						
	<ul>
		
			
				
					<li class="
                               
                               ">
						<a class="function"
							href="can-component.extend.html">
							extend
						</a>
						
					</li>
				

			
		
	</ul>


					</li>
				

			
		
	</ul>


						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-compute.html">
							can-compute
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-connect.html">
							can-connect
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-construct.html">
							can-construct
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-define.html">
							can-define
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-define/list/list.html">
							can-define/list/list
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-define/map/map.html">
							can-define/map/map
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="function"
							href="can-route.html">
							can-route
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-route-pushstate.html">
							can-route-pushstate
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-set.html">
							can-set
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-stache.html">
							can-stache
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="module"
							href="can-stache-bindings.html">
							can-stache-bindings
						</a>
						
					</li>
				

			
		
	</ul>


						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="can-ecosystem.html">
							Ecosystem
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="can-infrastructure.html">
							Infrastructure
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="can-legacy.html">
							Legacy
						</a>
						
					</li>
				

			
		
			
				
					<li class="
                               
                               ">
						<a class="page"
							href="guides.html">
							Guides
						</a>
						
					</li>
				

			
		
	</ul>


    
</nav>
  

  <div class="content-container">
    <article>
    	
    		<section class="title">
	<h1>viewModel</h1>
</section>

    	

        

    	
    		
    			<section class="description">
    <p>Provides or describes a <a href="can-map.html">can-map</a> constructor function or <code>Map</code> instance that will be
used to retrieve values found in the component's <a href="can-component.prototype.template.html">template</a>. The map
instance is initialized with values specified by the component element's attributes.</p>
<p><strong>Note:</strong> This page documents behavior of components in <a href="can-stache.html">can-stache</a>. [can-mustache] behaves
slightly differently. If you want the behavior of components with [can-mustache],
please look at versions of this page prior to 2.3. In 2.3, use <a href="can-stache-bindings.html">can-stache-bindings</a> <a href="can-stache-bindings.toChild.html">{to-child}</a>,
<a href="can-stache-bindings.toParent.html">{^to-parent}</a> and <a href="can-stache-bindings.twoWay.html">{(two-way)}</a> to setup viewModel
bindings.</p>

</section>

    		
    	

    
    
    
    <div class="signature">
  <h2 class="signature-title"><code>Object</code></h2>
  <p>A plain JavaScript object that is used to define the prototype methods and properties of
<a href="can-construct.html">constructor function</a> that extends <a href="can-map.html">can-map</a>. For example:</p>
<pre><code>Component.extend({
  tag: &quot;my-paginate&quot;,
  viewModel: {
    offset: 0,
    limit: 20,
    next: function(){
      this.attr(&quot;offset&quot;, this.offset + this.limit);
    }
  }
});
</code></pre>

  
  
  
  
  
  
</div>
    
    <div class="signature">
  <h2 class="signature-title"><code><a href="can-map.html" >can-map</a></code></h2>
  <p>A <code>Map</code> constructor function will be used to create an instance of the observable
<code>Map</code> placed at the head of the template's viewModel.  For example:</p>
<pre><code>var Paginate = Map.extend({
  offset: 0,
  limit: 20,
  next: function(){
    this.attr(&quot;offset&quot;, this.offset + this.limit);
  }
})
Component.extend({
  tag: &quot;my-paginate&quot;,
  viewModel: Paginate
})
</code></pre>

  
  
  
  
  
  
</div>
    
    <div class="signature">
  <h2 class="signature-title"><code>function(attrs, <a href="can-component.html" >parentScope</a>, element)</code></h2>
  <p>Returns the instance or constructor function of the object that will be added
to the viewModel.</p>

  
  
  <div class="parameters">
    <h3 class="parameters-title">Parameters</h3>
      <ol>
        
          <li><b>attrs</b> <code>{Object}</code>: <p>An object of values specified by the custom element's attributes. For example,
a template rendered like:</p>
<pre><code>stache(&quot;&lt;my-element title='name'&gt;&lt;/my-element&gt;&quot;)({
  name: &quot;Justin&quot;
})
</code></pre>
<p>Creates an instance of following control:</p>
<pre><code>Component.extend({
    tag: &quot;my-element&quot;,
    viewModel: function(attrs){
      attrs.title //-&gt; &quot;Justin&quot;;
      return new Map(attrs);
    }
})
</code></pre>
<p>And calls the viewModel function with <code>attrs</code> like <code>{title: &quot;Justin&quot;}</code>.</p>
</li>
        
          <li><b>parentScope</b> <code>{<a href="can-component.html" >can-component</a>|:|:|viewModel}</code>: <p>The viewModel the custom tag was found within.  By default, any attribute's values will
be looked up within the current viewModel, but if you want to add values without needing
the user to provide an attribute, you can set this up here.  For example:</p>
<pre><code>Component.extend({
    tag: &quot;my-element&quot;,
    viewModel: function(attrs, parentScope){
      return new Map({title: parentScope.attr('name')});
    }
});
</code></pre>
<p>Notice how the attribute's value is looked up in <code>my-element</code>'s parent viewModel.</p>
</li>
        
          <li><b>element</b> <code>{HTMLElement}</code>: <p>The element the <a href="can-component.html">can-component</a> is going to be placed on. If you want
to add custom attribute handling, you can do that here.  For example:</p>
<pre><code>Component.extend({
    tag: &quot;my-element&quot;,
    viewModel: function(attrs, parentScope, el){
      return new Map({title: el.getAttribute('title')});
    }
});
</code></pre>
</li>
        
      </ol>
  </div>
  
  
  
  <ul>
      <li><b>returns</b>  <code>{<a href="can-map.html" >can-map</a>|Object}</code>: <p>Specifies one of the following:</p>
<ul>
<li>The data used to render the component's template.</li>
<li>The prototype of a <code>Map</code> that will be used to render the component's template.</li>
</ul>
 </li>
  </ul>
  
  
  
</div>
    
    
    


    	
    		
    			<section class="body">
    <h2>Use</h2>
<p><a href="can-component.html">can-component</a>'s viewModel property is used to define an <strong>object</strong>, typically an instance
of a <a href="can-map.html">can-map</a>, that will be used to render the component's
template. This is most easily understood with an example.  The following
component shows the current page number based off a <code>limit</code> and <code>offset</code> value:</p>
<pre><code>Component.extend({
  tag: &quot;my-paginate&quot;,
  viewModel: {
    offset: 0,
    limit: 20,
    page: function(){
      return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
    }
  },
  template: stache(&quot;Page {{page}}.&quot;)
})
</code></pre>
<p>If this component HTML was inserted into the page like:</p>
<pre><code>var template = stache(&quot;&lt;my-paginate/&gt;&quot;)
$(&quot;body&quot;).append(template())
</code></pre>
<p>It would result in:</p>
<pre><code>&lt;my-paginate&gt;Page 1&lt;/my-paginate&gt;
</code></pre>
<p>This is because the provided viewModel object is used to extend a <a href="can-map.html">can-map</a> like:</p>
<pre><code>CustomMap = Map.extend({
  offset: 0,
  limit: 20,
  page: function(){
    return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
  }
})
</code></pre>
<p>Any primitives found on a <code>Map</code>'s prototype (ex: <code>offset: 0</code>) are used as
default values.</p>
<p>Next, a new instance of CustomMap is created with the attribute data within <code>&lt;my-paginate&gt;</code>
(in this case there is none) like:</p>
<pre><code>componentData = new CustomMap(attrs);
</code></pre>
<p>And finally, that data is added to the <a href="can-view-scope.html">parentScope</a> of the component, used to
render the component's template, and inserted into the element:</p>
<pre><code>var newviewModel = parentScope.add(componentData),
    result = stache(&quot;Page {{page}}.&quot;)(newviewModel);
$(element).html(result);
</code></pre>
<h2>Values passed from attributes</h2>
<p>Values can be &quot;passed&quot; into the viewModel of a component, similar to passing arguments into a function. Using
<a href="can-stache-bindings.html">can-stache-bindings</a>, the following binding types can be setup:</p>
<ul>
<li><a href="can-stache-bindings.toChild.html">{to-child}</a> - Update the component's viewModel when the parent scope value changes.</li>
<li><a href="can-stache-bindings.toParent.html">{^to-parent}</a> - Update the parent scope when the component's viewModel changes.</li>
<li><a href="can-stache-bindings.twoWay.html">{(two-way)}</a> - Update the parent scope or the component's viewModel when the other changes.</li>
</ul>
<p>As mentioned in the deprecation warning above, using <a href="can-stache.html">can-stache</a>, values are passed into components like this:</p>
<pre><code>&lt;my-paginate {offset}='index' {limit}='size'&gt;&lt;/my-paginate&gt;
</code></pre>
<p>The above would create an offset and limit property on the component that are initialized to whatever index and size are, NOT two-way bind (between component and parent viewModels)
the offset and limit properties to the index and size.</p>
<p>The following component requires an <code>offset</code> and <code>limit</code>:</p>
<pre><code>Component.extend({
  tag: &quot;my-paginate&quot;,
  viewModel: {
    page: function(){
      return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
    }
  },
  template: stache(&quot;Page {{page}}.&quot;)
});
</code></pre>
<p>If <code>&lt;my-paginate&gt;</code>'s source html is rendered like:</p>
<pre><code>var template = stache(&quot;&lt;my-paginate {offset}='index' {limit}='size'&gt;&lt;/my-paginate&gt;&quot;);

var pageInfo = new Map({
  index: 0,
  size: 20
});

$(&quot;body&quot;).append( template( pageInfo ) );
</code></pre>
<p>... <code>pageInfo</code>'s index and size are set as the component's offset and
limit attributes. If we were to change the value of <code>pageInfo</code>'s
index like:</p>
<pre><code>pageInfo.attr(&quot;index&quot;,20)
</code></pre>
<p>... the component's offset value will change and its template will update to:</p>
<pre><code>&lt;my-paginate&gt;Page 1&lt;/my-paginate&gt;
</code></pre>
<h3>Using attribute values</h3>
<p>You can also pass a literal string value of the attribute. To do this in <a href="can-stache.html">can-stache</a>,
simply pass any value not wrapped in single brackets, and the viewModel property will
be initialized to this string value:</p>
<pre><code>&lt;my-tag title=&quot;hello&quot;&gt;&lt;/my-tag&gt;
</code></pre>
<p>The above will create a title property in the component's viewModel, which has a string <code>hello</code>.</p>
<p>If the tag's <code>title</code> attribute is changed, it updates the viewModel property
automatically.  This can be seen in the following example:</p>
<div class='demo_wrapper' data-demo-src='demos/can-component/accordion.html'></div>
<p>Clicking the <strong>Change title</strong> button sets a <code>&lt;panel&gt;</code> element's <code>title</code> attribute like:</p>
<pre><code class="language-js">out.addEventListener(&quot;click&quot;, function(ev){
    var el = ev.target;
    var parent = el.parentNode;
    if(el.nodeName === &quot;BUTTON&quot;) {
        parent.setAttribute(&quot;title&quot;, &quot;Users&quot;);
        parent.removeChild(el);
    }
});
</code></pre>
<h2>Calling methods on viewModel from events within the template</h2>
<p>Using html attributes like <code>can-EVENT-METHOD</code>, you can directly call a viewModel method
from a template. For example, we can make <code>&lt;my-paginate&gt;</code> elements include a next
button that calls the viewModel's <code>next</code> method like:</p>
<pre><code class="language-js">var ViewModel = DefineMap.extend({
    offset: {
        value: 0
    },
    limit: {
        value: 20
    },
    next: function(){
        this.offset = this.offset + this.limit;
    },
    page: function(){
        return Math.floor(this.offset / this.limit) + 1;
    }
});

Component.extend({
    tag: &quot;my-paginate&quot;,
    ViewModel: ViewModel,
    template: stache(&quot;Page {{page}} &lt;button ($click)='next()'&gt;Next&lt;/button&gt;&quot;)
});
</code></pre>
<p>viewModel methods get called back with the current context, the element that you are listening to and the event that triggered the callback.</p>
<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next.html'></div>
<h2>Publishing events on viewModels</h2>
<p>Maps can publish events on themselves. For instance, the following <code>&lt;player-edit&gt;</code> component,
dispatches a <code>&quot;close&quot;</code> event when it's close method is called:</p>
<pre><code>Component.extend({
    tag: &quot;player-edit&quot;,
    template: stache($('#player-edit-stache').html()),
    ViewModel: DefineMap.extend({
        player: Player,
        close: function(){
            this.dispatch(&quot;close&quot;);
        }
    }),
    leakScope: true
});
</code></pre>
<p>These can be listened to with <a href="can-stache-bindings.event.html">(event)</a> bindings like:</p>
<pre><code>&lt;player-edit 
    (close)=&quot;removeEdit()&quot; 
    {player}=&quot;editingPlayer&quot;/&gt;
</code></pre>
<p>The following demo uses this ability to create a close button that
hides the player editor:</p>
<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>

</section>

    		
    	

    </article>
  </div>
</div>

  <footer><p>CanJS is part of <a href="http://donejs.com">DoneJS</a>. Created and maintained by the open source team at <a href="http://bitovi.com">Bitovi</a>. <strong>Currently v3.0.0.</strong></p></footer>
	<script type="text/javascript">
		var docObject = {"content":"<div class=\"main-container\">\n  \n  \t<nav class=\"sidebar\">\n    \n        \n\t<ul>\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               parent\n                               expanded\">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-core.html\">\n\t\t\t\t\t\t\tCore\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t<ul>\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               parent\n                               expanded\">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-component.html\">\n\t\t\t\t\t\t\tcan-component\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t<ul>\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<span>prototype</span>\n\n\t\t\t\t\t\t\n\t<ul>\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"property\"\n\t\t\t\t\t\t\thref=\"can-component.prototype.events.html\">\n\t\t\t\t\t\t\tevents\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"property\"\n\t\t\t\t\t\t\thref=\"can-component.prototype.helpers.html\">\n\t\t\t\t\t\t\thelpers\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"property\"\n\t\t\t\t\t\t\thref=\"can-component.prototype.leakScope.html\">\n\t\t\t\t\t\t\tleakScope\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"property\"\n\t\t\t\t\t\t\thref=\"can-component.prototype.tag.html\">\n\t\t\t\t\t\t\ttag\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"property\"\n\t\t\t\t\t\t\thref=\"can-component.prototype.template.html\">\n\t\t\t\t\t\t\ttemplate\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"current\n                               parent\n                               expanded\">\n\t\t\t\t\t\t<a class=\"property\"\n\t\t\t\t\t\t\thref=\"can-component.prototype.viewModel.html\">\n\t\t\t\t\t\t\tviewModel\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t</ul>\n\n\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<span>static</span>\n\n\t\t\t\t\t\t\n\t<ul>\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"function\"\n\t\t\t\t\t\t\thref=\"can-component.extend.html\">\n\t\t\t\t\t\t\textend\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t</ul>\n\n\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t</ul>\n\n\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-compute.html\">\n\t\t\t\t\t\t\tcan-compute\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-connect.html\">\n\t\t\t\t\t\t\tcan-connect\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-construct.html\">\n\t\t\t\t\t\t\tcan-construct\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-define.html\">\n\t\t\t\t\t\t\tcan-define\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-define/list/list.html\">\n\t\t\t\t\t\t\tcan-define/list/list\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-define/map/map.html\">\n\t\t\t\t\t\t\tcan-define/map/map\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"function\"\n\t\t\t\t\t\t\thref=\"can-route.html\">\n\t\t\t\t\t\t\tcan-route\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-route-pushstate.html\">\n\t\t\t\t\t\t\tcan-route-pushstate\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-set.html\">\n\t\t\t\t\t\t\tcan-set\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-stache.html\">\n\t\t\t\t\t\t\tcan-stache\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"module\"\n\t\t\t\t\t\t\thref=\"can-stache-bindings.html\">\n\t\t\t\t\t\t\tcan-stache-bindings\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t</ul>\n\n\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-ecosystem.html\">\n\t\t\t\t\t\t\tEcosystem\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-infrastructure.html\">\n\t\t\t\t\t\t\tInfrastructure\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"can-legacy.html\">\n\t\t\t\t\t\t\tLegacy\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li class=\"\n                               \n                               \">\n\t\t\t\t\t\t<a class=\"page\"\n\t\t\t\t\t\t\thref=\"guides.html\">\n\t\t\t\t\t\t\tGuides\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\n\t\t\t\t\t</li>\n\t\t\t\t\n\n\t\t\t\n\t\t\n\t</ul>\n\n\n    \n</nav>\n  \n\n  <div class=\"content-container\">\n    <article>\n    \t\n    \t\t<section class=\"title\">\n\t<h1>viewModel</h1>\n</section>\n\n    \t\n\n        \n\n    \t\n    \t\t\n    \t\t\t<section class=\"description\">\n    <p>Provides or describes a <a href=\"can-map.html\">can-map</a> constructor function or <code>Map</code> instance that will be\nused to retrieve values found in the component's <a href=\"can-component.prototype.template.html\">template</a>. The map\ninstance is initialized with values specified by the component element's attributes.</p>\n<p><strong>Note:</strong> This page documents behavior of components in <a href=\"can-stache.html\">can-stache</a>. [can-mustache] behaves\nslightly differently. If you want the behavior of components with [can-mustache],\nplease look at versions of this page prior to 2.3. In 2.3, use <a href=\"can-stache-bindings.html\">can-stache-bindings</a> <a href=\"can-stache-bindings.toChild.html\">{to-child}</a>,\n<a href=\"can-stache-bindings.toParent.html\">{^to-parent}</a> and <a href=\"can-stache-bindings.twoWay.html\">{(two-way)}</a> to setup viewModel\nbindings.</p>\n\n</section>\n\n    \t\t\n    \t\n\n    \n    \n    \n    <div class=\"signature\">\n  <h2 class=\"signature-title\"><code>Object</code></h2>\n  <p>A plain JavaScript object that is used to define the prototype methods and properties of\n<a href=\"can-construct.html\">constructor function</a> that extends <a href=\"can-map.html\">can-map</a>. For example:</p>\n<pre><code>Component.extend({\n  tag: &quot;my-paginate&quot;,\n  viewModel: {\n    offset: 0,\n    limit: 20,\n    next: function(){\n      this.attr(&quot;offset&quot;, this.offset + this.limit);\n    }\n  }\n});\n</code></pre>\n\n  \n  \n  \n  \n  \n  \n</div>\n    \n    <div class=\"signature\">\n  <h2 class=\"signature-title\"><code><a href=\"can-map.html\" >can-map</a></code></h2>\n  <p>A <code>Map</code> constructor function will be used to create an instance of the observable\n<code>Map</code> placed at the head of the template's viewModel.  For example:</p>\n<pre><code>var Paginate = Map.extend({\n  offset: 0,\n  limit: 20,\n  next: function(){\n    this.attr(&quot;offset&quot;, this.offset + this.limit);\n  }\n})\nComponent.extend({\n  tag: &quot;my-paginate&quot;,\n  viewModel: Paginate\n})\n</code></pre>\n\n  \n  \n  \n  \n  \n  \n</div>\n    \n    <div class=\"signature\">\n  <h2 class=\"signature-title\"><code>function(attrs, <a href=\"can-component.html\" >parentScope</a>, element)</code></h2>\n  <p>Returns the instance or constructor function of the object that will be added\nto the viewModel.</p>\n\n  \n  \n  <div class=\"parameters\">\n    <h3 class=\"parameters-title\">Parameters</h3>\n      <ol>\n        \n          <li><b>attrs</b> <code>{Object}</code>: <p>An object of values specified by the custom element's attributes. For example,\na template rendered like:</p>\n<pre><code>stache(&quot;&lt;my-element title='name'&gt;&lt;/my-element&gt;&quot;)({\n  name: &quot;Justin&quot;\n})\n</code></pre>\n<p>Creates an instance of following control:</p>\n<pre><code>Component.extend({\n    tag: &quot;my-element&quot;,\n    viewModel: function(attrs){\n      attrs.title //-&gt; &quot;Justin&quot;;\n      return new Map(attrs);\n    }\n})\n</code></pre>\n<p>And calls the viewModel function with <code>attrs</code> like <code>{title: &quot;Justin&quot;}</code>.</p>\n</li>\n        \n          <li><b>parentScope</b> <code>{<a href=\"can-component.html\" >can-component</a>|:|:|viewModel}</code>: <p>The viewModel the custom tag was found within.  By default, any attribute's values will\nbe looked up within the current viewModel, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:</p>\n<pre><code>Component.extend({\n    tag: &quot;my-element&quot;,\n    viewModel: function(attrs, parentScope){\n      return new Map({title: parentScope.attr('name')});\n    }\n});\n</code></pre>\n<p>Notice how the attribute's value is looked up in <code>my-element</code>'s parent viewModel.</p>\n</li>\n        \n          <li><b>element</b> <code>{HTMLElement}</code>: <p>The element the <a href=\"can-component.html\">can-component</a> is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:</p>\n<pre><code>Component.extend({\n    tag: &quot;my-element&quot;,\n    viewModel: function(attrs, parentScope, el){\n      return new Map({title: el.getAttribute('title')});\n    }\n});\n</code></pre>\n</li>\n        \n      </ol>\n  </div>\n  \n  \n  \n  <ul>\n      <li><b>returns</b>  <code>{<a href=\"can-map.html\" >can-map</a>|Object}</code>: <p>Specifies one of the following:</p>\n<ul>\n<li>The data used to render the component's template.</li>\n<li>The prototype of a <code>Map</code> that will be used to render the component's template.</li>\n</ul>\n </li>\n  </ul>\n  \n  \n  \n</div>\n    \n    \n    \n\n\n    \t\n    \t\t\n    \t\t\t<section class=\"body\">\n    <h2>Use</h2>\n<p><a href=\"can-component.html\">can-component</a>'s viewModel property is used to define an <strong>object</strong>, typically an instance\nof a <a href=\"can-map.html\">can-map</a>, that will be used to render the component's\ntemplate. This is most easily understood with an example.  The following\ncomponent shows the current page number based off a <code>limit</code> and <code>offset</code> value:</p>\n<pre><code>Component.extend({\n  tag: &quot;my-paginate&quot;,\n  viewModel: {\n    offset: 0,\n    limit: 20,\n    page: function(){\n      return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n    }\n  },\n  template: stache(&quot;Page {{page}}.&quot;)\n})\n</code></pre>\n<p>If this component HTML was inserted into the page like:</p>\n<pre><code>var template = stache(&quot;&lt;my-paginate/&gt;&quot;)\n$(&quot;body&quot;).append(template())\n</code></pre>\n<p>It would result in:</p>\n<pre><code>&lt;my-paginate&gt;Page 1&lt;/my-paginate&gt;\n</code></pre>\n<p>This is because the provided viewModel object is used to extend a <a href=\"can-map.html\">can-map</a> like:</p>\n<pre><code>CustomMap = Map.extend({\n  offset: 0,\n  limit: 20,\n  page: function(){\n    return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n  }\n})\n</code></pre>\n<p>Any primitives found on a <code>Map</code>'s prototype (ex: <code>offset: 0</code>) are used as\ndefault values.</p>\n<p>Next, a new instance of CustomMap is created with the attribute data within <code>&lt;my-paginate&gt;</code>\n(in this case there is none) like:</p>\n<pre><code>componentData = new CustomMap(attrs);\n</code></pre>\n<p>And finally, that data is added to the <a href=\"can-view-scope.html\">parentScope</a> of the component, used to\nrender the component's template, and inserted into the element:</p>\n<pre><code>var newviewModel = parentScope.add(componentData),\n    result = stache(&quot;Page {{page}}.&quot;)(newviewModel);\n$(element).html(result);\n</code></pre>\n<h2>Values passed from attributes</h2>\n<p>Values can be &quot;passed&quot; into the viewModel of a component, similar to passing arguments into a function. Using\n<a href=\"can-stache-bindings.html\">can-stache-bindings</a>, the following binding types can be setup:</p>\n<ul>\n<li><a href=\"can-stache-bindings.toChild.html\">{to-child}</a> - Update the component's viewModel when the parent scope value changes.</li>\n<li><a href=\"can-stache-bindings.toParent.html\">{^to-parent}</a> - Update the parent scope when the component's viewModel changes.</li>\n<li><a href=\"can-stache-bindings.twoWay.html\">{(two-way)}</a> - Update the parent scope or the component's viewModel when the other changes.</li>\n</ul>\n<p>As mentioned in the deprecation warning above, using <a href=\"can-stache.html\">can-stache</a>, values are passed into components like this:</p>\n<pre><code>&lt;my-paginate {offset}='index' {limit}='size'&gt;&lt;/my-paginate&gt;\n</code></pre>\n<p>The above would create an offset and limit property on the component that are initialized to whatever index and size are, NOT two-way bind (between component and parent viewModels)\nthe offset and limit properties to the index and size.</p>\n<p>The following component requires an <code>offset</code> and <code>limit</code>:</p>\n<pre><code>Component.extend({\n  tag: &quot;my-paginate&quot;,\n  viewModel: {\n    page: function(){\n      return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n    }\n  },\n  template: stache(&quot;Page {{page}}.&quot;)\n});\n</code></pre>\n<p>If <code>&lt;my-paginate&gt;</code>'s source html is rendered like:</p>\n<pre><code>var template = stache(&quot;&lt;my-paginate {offset}='index' {limit}='size'&gt;&lt;/my-paginate&gt;&quot;);\n\nvar pageInfo = new Map({\n  index: 0,\n  size: 20\n});\n\n$(&quot;body&quot;).append( template( pageInfo ) );\n</code></pre>\n<p>... <code>pageInfo</code>'s index and size are set as the component's offset and\nlimit attributes. If we were to change the value of <code>pageInfo</code>'s\nindex like:</p>\n<pre><code>pageInfo.attr(&quot;index&quot;,20)\n</code></pre>\n<p>... the component's offset value will change and its template will update to:</p>\n<pre><code>&lt;my-paginate&gt;Page 1&lt;/my-paginate&gt;\n</code></pre>\n<h3>Using attribute values</h3>\n<p>You can also pass a literal string value of the attribute. To do this in <a href=\"can-stache.html\">can-stache</a>,\nsimply pass any value not wrapped in single brackets, and the viewModel property will\nbe initialized to this string value:</p>\n<pre><code>&lt;my-tag title=&quot;hello&quot;&gt;&lt;/my-tag&gt;\n</code></pre>\n<p>The above will create a title property in the component's viewModel, which has a string <code>hello</code>.</p>\n<p>If the tag's <code>title</code> attribute is changed, it updates the viewModel property\nautomatically.  This can be seen in the following example:</p>\n<div class='demo_wrapper' data-demo-src='demos/can-component/accordion.html'></div>\n<p>Clicking the <strong>Change title</strong> button sets a <code>&lt;panel&gt;</code> element's <code>title</code> attribute like:</p>\n<pre><code class=\"language-js\">out.addEventListener(&quot;click&quot;, function(ev){\n    var el = ev.target;\n    var parent = el.parentNode;\n    if(el.nodeName === &quot;BUTTON&quot;) {\n        parent.setAttribute(&quot;title&quot;, &quot;Users&quot;);\n        parent.removeChild(el);\n    }\n});\n</code></pre>\n<h2>Calling methods on viewModel from events within the template</h2>\n<p>Using html attributes like <code>can-EVENT-METHOD</code>, you can directly call a viewModel method\nfrom a template. For example, we can make <code>&lt;my-paginate&gt;</code> elements include a next\nbutton that calls the viewModel's <code>next</code> method like:</p>\n<pre><code class=\"language-js\">var ViewModel = DefineMap.extend({\n    offset: {\n        value: 0\n    },\n    limit: {\n        value: 20\n    },\n    next: function(){\n        this.offset = this.offset + this.limit;\n    },\n    page: function(){\n        return Math.floor(this.offset / this.limit) + 1;\n    }\n});\n\nComponent.extend({\n    tag: &quot;my-paginate&quot;,\n    ViewModel: ViewModel,\n    template: stache(&quot;Page {{page}} &lt;button ($click)='next()'&gt;Next&lt;/button&gt;&quot;)\n});\n</code></pre>\n<p>viewModel methods get called back with the current context, the element that you are listening to and the event that triggered the callback.</p>\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next.html'></div>\n<h2>Publishing events on viewModels</h2>\n<p>Maps can publish events on themselves. For instance, the following <code>&lt;player-edit&gt;</code> component,\ndispatches a <code>&quot;close&quot;</code> event when it's close method is called:</p>\n<pre><code>Component.extend({\n    tag: &quot;player-edit&quot;,\n    template: stache($('#player-edit-stache').html()),\n    ViewModel: DefineMap.extend({\n        player: Player,\n        close: function(){\n            this.dispatch(&quot;close&quot;);\n        }\n    }),\n    leakScope: true\n});\n</code></pre>\n<p>These can be listened to with <a href=\"can-stache-bindings.event.html\">(event)</a> bindings like:</p>\n<pre><code>&lt;player-edit \n    (close)=&quot;removeEdit()&quot; \n    {player}=&quot;editingPlayer&quot;/&gt;\n</code></pre>\n<p>The following demo uses this ability to create a close button that\nhides the player editor:</p>\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n</section>\n\n    \t\t\n    \t\n\n    </article>\n  </div>\n</div>\n","src":{"path":"node_modules/can-component/docs/view-model.md"},"description":" \nProvides or describes a [can-map] constructor function or `Map` instance that will be\nused to retrieve values found in the component's [can-component::template template]. The map \ninstance is initialized with values specified by the component element's attributes.\n\n__Note:__ This page documents behavior of components in [can-stache]. [can-mustache] behaves\nslightly differently. If you want the behavior of components with [can-mustache], \nplease look at versions of this page prior to 2.3. In 2.3, use [can-stache-bindings] [can-stache-bindings.toChild], \n[can-stache-bindings.toParent] and [can-stache-bindings.twoWay] to setup viewModel \nbindings.\n\n","types":[{"type":"Object","description":"A plain JavaScript object that is used to define the prototype methods and properties of\n[can-construct constructor function] that extends [can-map]. For example:\n\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: {\n        offset: 0,\n        limit: 20,\n        next: function(){\n          this.attr(\"offset\", this.offset + this.limit);\n        }\n      }\n    });\n","options":[]},{"type":"can-map","description":"A `Map` constructor function will be used to create an instance of the observable\n`Map` placed at the head of the template's viewModel.  For example:\n\n    var Paginate = Map.extend({\n      offset: 0,\n      limit: 20,\n      next: function(){\n        this.attr(\"offset\", this.offset + this.limit);\n      }\n    })\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: Paginate\n    })\n    \n"},{"type":"function","returns":{"types":[{"type":"can-map","description":"If an instance of `Map` is returned, that instance is placed\non top of the viewModel and used to render the component's template.\n"},{"type":"Object","options":[],"description":"If a plain JavaScript object is returned, that is used as a prototype\ndefinition used to extend `Map`.  A new instance of the extended Map is created.\n"}],"description":"Specifies one of the following:\n\n - The data used to render the component's template.\n - The prototype of a `Map` that will be used to render the component's template.\n "},"params":[{"types":[{"type":"Object","options":[]}],"name":"attrs","description":"An object of values specified by the custom element's attributes. For example,\na template rendered like:\n\n    stache(\"<my-element title='name'></my-element>\")({\n      name: \"Justin\"\n    })\n\nCreates an instance of following control:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs){\n    \t  attrs.title //-> \"Justin\";\n    \t  return new Map(attrs);\n    \t}\n    })\n\nAnd calls the viewModel function with `attrs` like `{title: \"Justin\"}`.\n"},{"types":[{"type":"can-component"},{"type":":"},{"type":":"},{"type":"viewModel"}],"name":"parentScope","description":"\n\nThe viewModel the custom tag was found within.  By default, any attribute's values will\nbe looked up within the current viewModel, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs, parentScope){\n    \t  return new Map({title: parentScope.attr('name')});\n    \t}\n    });\n\nNotice how the attribute's value is looked up in `my-element`'s parent viewModel.\n"},{"types":[{"type":"HTMLElement"}],"name":"element","description":"The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs, parentScope, el){\n    \t  return new Map({title: el.getAttribute('title')});\n    \t}\n    });\n"}],"description":"Returns the instance or constructor function of the object that will be added\nto the viewModel.\n"}],"title":"viewModel","name":"can-component.prototype.viewModel","type":"property","parent":"can-component.prototype","_curParam":{"types":[{"type":"HTMLElement"}],"name":"element","description":"The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs, parentScope, el){\n    \t  return new Map({title: el.getAttribute('title')});\n    \t}\n    });\n"},"_curReturn":{"types":[{"type":"can-map","description":"If an instance of `Map` is returned, that instance is placed\non top of the viewModel and used to render the component's template.\n"},{"type":"Object","options":[],"description":"If a plain JavaScript object is returned, that is used as a prototype\ndefinition used to extend `Map`.  A new instance of the extended Map is created.\n"}],"description":"Specifies one of the following:\n\n - The data used to render the component's template.\n - The prototype of a `Map` that will be used to render the component's template.\n "},"comment":" "};
	</script>

	
		<script>
		  steal = {
		    instantiated: {
		      "bundles/bit-docs-site/static.css!$css" : null
		    }
		  }
		</script>
		<script type='text/javascript'
				data-main="bit-docs-site/static"
				src="./static/node_modules/steal/steal.production.js"></script>
	
</body>

</html>
